Destructuring:
  - a way to unpack values from arrays or variables. breaks complex data structures down to simple structures

- Arrays:
  - Destructuring arrays assignment uses []
  Ex: const arr = [2, 3, 4]
  const [x, y, z] = arr 
  console.log(x, y, z) // 2 3 4
  - x, y and z take their values from the values in the already existing arr via destructuring
  - destructuring is always on the left side of the equal sign
  - destructuring doesnt change the original array

  - to skip an element while destructuring, add a blank placeholder
    Ex: const [x, , z] = arr // x = 2, z = 4
    - only x and z will be created from arr

  - variables can be created with destructuing via function calls
  Ex: const [starter, mainCourse] = restaurant.order(2, 0) 
  - starter and mainCourse will equal the return values of the function

  - destructure nested arrays with inner destructuing assignments
  Ex: const nested = [2, 4, [5, 6]]
  const [i, , [j, k]] = nested // 2 5 6
  - without the inner destructuing assignment, j would equal the nested array element itself from the nested variable ([5 ,6])

  - set default values inside of a destructuing assignment with = 
  Ex: const [p = 1, q = 1, r = 1] = [8, 9];
  console.log(p, q, r); // 8 9 1
  - r remains its default because the array that it's destructuring from doesnt have a 3rd element
  - without the defaults, r would return undefined
  - useful when data is being received from an API 

- Objects:
  - {} for destructuing objects
  - since order in objects doesnt matter, it doesnt matter when destructuring either. no need for skipping like arrays. but the names must match a variabel in the destructured object 
  - variable names can be changed within destructuring
  Ex: const {name: restaurantName, openingHours: hours} = restaurant; 
  - defaults are the same as arrays
  - to add a value to an object, you can destructure it and give it a default
  Ex: { menu = [], starterMenu: starters = [] } = restaurant;
    - starterMenu will be renamed to starters and if it wanst already in the restaurant object, its value would be []
  - when mutating variables, a js line cannot start with { unless a code block follows
    - this wont work: {a, b} = obj; an error will be thrown
    - therefore adding () around the entire thing will fix it 
      Ex: ({a, b} = obj)
  - nested variables:
    Ex: const { fri: {open, close} } = openingHours; //open = 11, close = 23

Spread Operator:
- brings individual elements from a comma separated iterable (when building an array or passing into a function) into wherever its called
  Ex: const arr = [7, 8, 9]
  const arr2 = [1, 2, ...arr]
  console.log(...arr2) // 1 2 7 8 9
- used where there would be values separated by a comma
- iterables: arrays, strings, maps, sets (not objects)
- this does not manipulate the original array, it creates a copy
- always on the right side of the assignment operator
- making a shallow copy of an array:
  const arr2Copy = [...arr2]
- merging arrays:
  const arr3 = [...arr, ...arr2] // [7, 8, 9, 1, 2, 7, 8, 9]
- since ES2018, the spread operator also works on objects
- spread operator creates a copy of object, does not manipulate original

Rest Operator:
- opposite of spread operator
- used where there would be variable names separated by a comma

- Destructuring:
  - collects unused variables in destructuing assignments and packs them into an array
  - does not include any skipped items
  - must be the last element in destructuring assignment
  - only one rest operator per destructuing assignment
  - always on the left side of the assignment operator
  - with arrays, it creates new arrays
  - with objects, it creates new objects

- Functions
  - using rest with the parameters is called a rest parameters
  Ex: const add = function (...numbers) {}
  - this allows an arbitrary amount of parameters to be used in the function

Short Circuiting:
  - evaluates operands and stops it as soon as the result is determined 
  - this works because the rules of the operator are being met early therefore the rest of the operands dont need to be evaluated
  - logical operators can use and return any data type

- || operator:
  - returns the first truthy value to occur within an operand
  - if there are no truthy values, it will return the last operand
  - Ex: console.log(3 || 'ricky') // returns 3
  - Ex: console.log(0 || 'ricky') // returns ricky
  - Ex: console.log(0 || 'ricky' || 11) // returns ricky
  - easy way to set a default value instead of ternary operator

- && operator:
  - returns the first falsy value to occur within an operand
  - if there are no falsy values, it will return the last operand
  - Ex: console.log(0 && 'ricky'); // returns 0
  - Ex: console.log(2 && 'ricky'); // returns ricky
  - Ex: console.log(2 && 'ricky' && null && 'hello'); // returns null
  - can help you find if something exists without an if/else statement

- nullish coalescing
  - works similar to the || operator but returns value that isnt nullish (null or undefined)
  - helps when a falsy value is needed to pretend to be truthy value
  - Ex: 
      restaurant.numGuests = 0;
      const guests = restaurant.numGuests || 10; //returns 10
      const guestCorrect = restaurant.numGuests ?? 10; //returns 0
  - will work as a || operator if there are no nullish values

Logical Assignment Operators
- using short circuiting to help assign
- OR: ||=
  Ex: rest1 = { name: 'rest 1', guests: 20}
  rest1.guests = rest1.guests || 10 // returns 20
  rest1.guests ||= 10 (same as above)
- AND: &&=
  Ex: rest1.owner = rest1.owner && '<ANONYMOUS>';
    - adds owner: undefined to rest1 object
  rest1.owner &&= '<ANONYMOUS>';
    - doesnt add the owner key/value because its changing anything thats already truthy. owner in rest1 doesnt exist so its not truthy. otherwise itll just change the value
- nullish: ??=
  Ex: rest1 = { name: 'rest 1', guests: 0}
  rest1.guests = rest1.guests ?? 10 // returns 0
  rest1.guests ??= 10 (same as above)

For-of loop:
- automatically loop over an array and give access to each element
  Ex: for (const item of menu) {
    console.log(item)
  }
- helps eliminate the use of a counter variable
- can still use break and continue
- using the .entries() method will return an array for each element that is looped over with its index followed by its value
  Ex: for (const item of menu.entries()) {
    console.log(item)
  }
  - returns [0, 'item 1'], [1, 'item 2'], etc
  - .entries() is an array iterator

Enhancing object literals:
- when injecting an outside object into another object, there is no need to write it as a key/value pair. writing it once will inject the entire object and JS knows to use it as a key/value pair
  Ex: const obj1 = { one: 1, two: 2}
      const obl2 = {obj1, three: 3, four: 4}
  - unlike the spread operator, it will inject the actual object as it was into the other object not just individual pieces
- when writing methods, there is no longer a need for a key/value pair inside an object
- since ES6, the function keyword and the colon can be omitted
  Ex: order: function() {} // old way
      order() {} // new way
- property names can be computed inside objects
  Ex: const weekdays = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
  const openingHours = {
    [weekdays[3]]: {
      open: 12,
      close: 22,
    },
    [weekdays[4]]: {
      open: 11,
      close: 23,
    },
    [weekdays[5]]: {
      open: 0, // Open 24 hours
      close: 24,
    },
  }; 

Optional Chaining:
- checks to see if a property exists before moving onto the next property
- used by adding a ?. after the property that may not exist
  Ex: console.log(restaurant.openingHours.mon?.open)
  - js is going to check if the .mon property exists (not null or undefined)
  - if it does, it continues. if it doesnt, it immediately returns undefined  
- without optional chaining, js will throw an error
- this helps prevent the code to throw errors and stop because something doesnt exist
  Ex: console.log(restaurant.openingHours.mon.open) //throws error
- can have multiple optional chaining in one line
  Ex: console.log(restaurant.openingHours?.mon?.open)
- can be used to see if methods exists
  Ex: console.log(restaurant.order?.(0, 1) ?? 'Method doesnt exist');
- when using optional chaining, its common to use ?? with it to set a default in case the optional chaining doesnt exist

Looping Objects:
- Keys:
  - Object.keys(obj1) returns an array of all the keys (as strings) in the obj1 object
- Values:
  - Object.values(obj1) returns an array of all the values (as they are) in the obj1 object
- Entries:
  - Object.entries(obj1) returns an array of all the key/value pairs (as arrays) in the obj1 object
  - in each array the key will be the first element as a string and the second element will be the values as it is in its original object
    - a combo of the .keys() and the .values() combined into an array
  - unlike on arrays, the object is called in the method rather than calling the method on the array
    - arr.entries() vs Object.entries(obj1)