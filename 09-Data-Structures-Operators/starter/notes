Destructuring:
  - a way to unpack values from arrays or variables. breaks complex data structures down to simple structures

- Arrays:
  - Destructuring arrays assignment uses []
  Ex: const arr = [2, 3, 4]
  const [x, y, z] = arr 
  console.log(x, y, z) // 2 3 4
  - x, y and z take their values from the values in the already existing arr via destructuring
  - destructuring is always on the left side of the equal sign
  - destructuring doesnt change the original array

  - to skip an element while destructuring, add a blank placeholder
    Ex: const [x, , z] = arr // x = 2, z = 4
    - only x and z will be created from arr

  - variables can be created with destructuing via function calls
  Ex: const [starter, mainCourse] = restaurant.order(2, 0) 
  - starter and mainCourse will equal the return values of the function

  - destructure nested arrays with inner destructuing assignments
  Ex: const nested = [2, 4, [5, 6]]
  const [i, , [j, k]] = nested // 2 5 6
  - without the inner destructuing assignment, j would equal the array element from the nested variable ([5 ,6])

  - set default values inside of a destructuing assignment with = 
  Ex: const [p = 1, q = 1, r = 1] = [8, 9];
  console.log(p, q, r); // 8 9 1
  - r remains its default because the array on the right doesnt have a 3rd element
  - without the defaults, r would return undefined
  - useful when data is being received from an API 

- Objects:
  - {} for destructuing objects
  - since order in objects dont matter, it doesnt matter when destructuring either. no need for skipping
  - variable names can be changed within destructuring
  Ex: const {name: restaurantName, openingHours: hours} = restaurant; 
  - defaults are the same as arrays
  - to add to a value to an object, you can destructure it and give it a default
  Ex: { menu = [], starterMenu: starters = [] } = restaurant;
    - starterMenu will be renamed to starters and if it wanst already in the restaurant object, its value would be []
  - when mutating variables, a js line cannot start with { unless a code block follows
  - this wont work: {a, b} = obj; an error will be thrown
  - therefore adding () around the entire thing will work. ({a, b} = obj)
  - nested variables:
    Ex: const { fri: {open, close} } = openingHours; //open = 11, close = 23
  console.log(...arr2) // 1 2 7 8 9

Spread Operator:
- brings individual elements from a comma separated iterable (when building an array or passing into a function) into wherever its called
  Ex: const arr = [7, 8, 9]
  const arr2 = [1, 2, ...arr] // [1, 2, 7, 8, 9]
- used where there would be values separated by a comma
- iterables: arrays, strings, maps, sets (not objects)
- this does not manipulate the original array, it creates a copy
- always on the right side of the assignment operator
- making a shallow copy of an array:
  const arr2Copy = [...arr2]
- merging arrays:
  const arr3 = [...arr, ...arr2] // [7, 8, 9, 1, 2, 7, 8, 9]
- since ES2018, the spread operator also works on objects
- spread operator creates a copy of object, does not manipulate original

Rest Operator:
- opposite of spread operator
- used where there would be variable names separated by a comma

- Destructuring:
  - collects unused variables after the last variable in destructuing assignments and packs them into an array
  - does not include any skipped items
  - must be the last element in destructuring assignment
  - only one rest operator per destructuing assignment
  - always on the left side of the assignment operator
  - with arrays, it creates new arrays
  - with objects, it creates new objects

- Functions
  - using rest with the parameters is called a rest parameters
  Ex: const add = function (...numbers) {}

Short Circuiting:
  - evaluates operands and stops it as soon as the result is determined 
  - this works because the rules of the operator are being met without having to evaluate the rest of the operands
  - logical operators can use and return any data type

- || operator:
  - returns the first truthy value to occur within an operand
  - if there are no truthy values, it will return the last operand
  - Ex: console.log(3 || 'ricky') // returns 3
  - Ex: console.log(0 || 'ricky') // returns ricky
  - Ex: console.log(0 || 'ricky' || 11) // returns ricky
  - easy way to set a default value instead of ternary operator

- && operator:
  - returns the first falsy value to occur within an operand
  - if there are no falsy values, it will return the last operand
  - Ex: console.log(0 && 'ricky'); // returns 0
  - Ex: console.log(2 && 'ricky'); // returns ricky
  - Ex: console.log(2 && 'ricky' && null && 'hello'); // returns null
  - can help you find is something exists without an if statement

- nullish coalescing
  - works similar to the || operator but returns value that isnt nullish (null or undefined)
  - Ex: 
      restaurant.numGuests = 0;
      const guests = restaurant.numGuests || 10; //returns 10
      const guestCorrect = restaurant.numGuests ?? 10; //returns 0
  - helps when a falsy value is needed to pretend to be truthy value
  - will work as a || operator if there are no nullish values




  

